/*
 * stm32f407xx_spi_driver.c
 *
 * Minimal blocking-mode SPI driver for STM32F407
 */

#include "stm32f407xx_spi_driver.h"

/* =============== Local helpers (bit positions in control/status regs) =============== */
/* CR1 bits */
#define SPI_CR1_CPHA_Pos     0U
#define SPI_CR1_CPOL_Pos     1U
#define SPI_CR1_MSTR_Pos     2U
#define SPI_CR1_BR_Pos       3U  /* [5:3] */
#define SPI_CR1_SPE_Pos      6U
#define SPI_CR1_LSBFIRST_Pos 7U
#define SPI_CR1_SSI_Pos      8U
#define SPI_CR1_SSM_Pos      9U
#define SPI_CR1_RXONLY_Pos   10U
#define SPI_CR1_DFF_Pos      11U
#define SPI_CR1_BIDIOE_Pos   14U
#define SPI_CR1_BIDIMODE_Pos 15U

/* CR2 bits */
#define SPI_CR2_SSOE_Pos     2U

/* SR flags are defined in the header as masks */

/* ============================== Clock control ============================== */
void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi == ENABLE)
	{
		if (pSPIx == SPI1)
		{
			RCC->APB2ENR |= (1U << 12); /* SPI1EN */
		}
		else if (pSPIx == SPI2)
		{
			RCC->APB1ENR |= (1U << 14); /* SPI2EN */
		}
		else if (pSPIx == SPI3)
		{
			RCC->APB1ENR |= (1U << 15); /* SPI3EN */
		}
	}
	else
	{
		if (pSPIx == SPI1)
		{
			RCC->APB2ENR &= ~(1U << 12);
		}
		else if (pSPIx == SPI2)
		{
			RCC->APB1ENR &= ~(1U << 14);
		}
		else if (pSPIx == SPI3)
		{
			RCC->APB1ENR &= ~(1U << 15);
		}
	}
}

/* ================================ Init ===================================== */
void SPI_Init(SPI_Handle_t *pSPIHandle)
{
	uint32_t tempreg = 0;

	/* 1) Enable peripheral clock first */
	SPI_PeriClockControl(pSPIHandle->pSPIx, ENABLE);

	/* 2) Configure device mode */
	if (pSPIHandle->SPIConfig.SPI_DeviceMode == SPI_DEVICE_MODE_MASTER)
	{
		tempreg |= (1U << SPI_CR1_MSTR_Pos);
	}

	/* 3) Configure bus config */
	switch (pSPIHandle->SPIConfig.SPI_BusConfig)
	{
	case SPI_BUS_CONFIG_FD:
		/* Full duplex: BIDIMODE=0, RXONLY=0 */
		tempreg &= ~(1U << SPI_CR1_BIDIMODE_Pos);
		tempreg &= ~(1U << SPI_CR1_RXONLY_Pos);
		break;

	case SPI_BUS_CONFIG_HD:
		/* Half duplex: BIDIMODE=1 (single line) */
		tempreg |= (1U << SPI_CR1_BIDIMODE_Pos);
		/* BIDIOE controls direction when master transmitting; leave to user if needed */
		break;

	case SPI_BUS_CONFIG_SIMPLEX_RX:
		/* Simplex RX-only: BIDIMODE=0, RXONLY=1 */
		tempreg &= ~(1U << SPI_CR1_BIDIMODE_Pos);
		tempreg |=  (1U << SPI_CR1_RXONLY_Pos);
		break;

	default:
		/* default to full duplex */
		tempreg &= ~(1U << SPI_CR1_BIDIMODE_Pos);
		tempreg &= ~(1U << SPI_CR1_RXONLY_Pos);
		break;
	}

	/* 4) Configure clock speed (BR) */
	tempreg &= ~(0x7U << SPI_CR1_BR_Pos);
	tempreg |=  ((pSPIHandle->SPIConfig.SPI_SclkSpeed & 0x7U) << SPI_CR1_BR_Pos);

	/* 5) CPOL & CPHA */
	if (pSPIHandle->SPIConfig.SPI_CPOL == SPI_CPOL_HIGH)
		tempreg |= (1U << SPI_CR1_CPOL_Pos);
	else
		tempreg &= ~(1U << SPI_CR1_CPOL_Pos);

	if (pSPIHandle->SPIConfig.SPI_CPHA == SPI_CPHA_HIGH)
		tempreg |= (1U << SPI_CR1_CPHA_Pos);
	else
		tempreg &= ~(1U << SPI_CR1_CPHA_Pos);

	/* 6) DFF (8/16-bit) */
	if (pSPIHandle->SPIConfig.SPI_DFF == SPI_DFF_16BITS)
		tempreg |= (1U << SPI_CR1_DFF_Pos);
	else
		tempreg &= ~(1U << SPI_CR1_DFF_Pos);

	/* 7) Software slave management */
	if (pSPIHandle->SPIConfig.SPI_SSM == SPI_SSM_EN)
	{
		tempreg |= (1U << SPI_CR1_SSM_Pos);
		/* Optionally set SSI to avoid MODF when in master */
		tempreg |= (1U << SPI_CR1_SSI_Pos);
	}
	else
	{
		tempreg &= ~(1U << SPI_CR1_SSM_Pos);
	}

	/* MSB first by default */
	tempreg &= ~(1U << SPI_CR1_LSBFIRST_Pos);

	/* Write CR1 */
	pSPIHandle->pSPIx->CR1 = tempreg;

	/* If hardware NSS management is desired later, use SSOE helper below */
}

void SPI_DeInit(SPI_RegDef_t *pSPIx)
{
	if (pSPIx == SPI1)
	{
		RCC->APB2RSTR |=  (1U << 12);
		RCC->APB2RSTR &= ~(1U << 12);
	}
	else if (pSPIx == SPI2)
	{
		RCC->APB1RSTR |=  (1U << 14);
		RCC->APB1RSTR &= ~(1U << 14);
	}
	else if (pSPIx == SPI3)
	{
		RCC->APB1RSTR |=  (1U << 15);
		RCC->APB1RSTR &= ~(1U << 15);
	}
}

/* =============================== I/O (blocking) ============================ */
uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName)
{
	return (pSPIx->SR & FlagName) ? 1U : 0U;
}

void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len)
{
	while (Len > 0)
	{
		/* Wait until TXE is set */
		while (!SPI_GetFlagStatus(pSPIx, SPI_TXE_FLAG));

		if (pSPIx->CR1 & (1U << SPI_CR1_DFF_Pos))
		{
			/* 16-bit dff */
			pSPIx->DR = *((uint16_t *)pTxBuffer);
			pTxBuffer += 2;
			Len -= (Len >= 2) ? 2 : 1; /* guard for odd len */
		}
		else
		{
			/* 8-bit dff */
			pSPIx->DR = *pTxBuffer;
			pTxBuffer++;
			Len--;
		}
	}

	/* Wait for BSY to clear (complete last transfer) */
	while (SPI_GetFlagStatus(pSPIx, SPI_BUSY_FLAG));
	/* Clear OVR if RX path was ignored in full-duplex (optional) */
}

void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len)
{
	while (Len > 0)
	{
		/* Wait until RXNE is set */
		while (!SPI_GetFlagStatus(pSPIx, SPI_RXNE_FLAG));

		if (pSPIx->CR1 & (1U << SPI_CR1_DFF_Pos))
		{
			/* 16-bit dff */
			*((uint16_t *)pRxBuffer) = (uint16_t)pSPIx->DR;
			pRxBuffer += 2;
			Len -= (Len >= 2) ? 2 : 1;
		}
		else
		{
			*pRxBuffer = (uint8_t)pSPIx->DR;
			pRxBuffer++;
			Len--;
		}
	}
}

/* =============================== Controls ================================== */
void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi == ENABLE)
		pSPIx->CR1 |=  (1U << SPI_CR1_SPE_Pos);
	else
		pSPIx->CR1 &= ~(1U << SPI_CR1_SPE_Pos);
}

void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi == ENABLE)
		pSPIx->CR1 |=  (1U << SPI_CR1_SSI_Pos);
	else
		pSPIx->CR1 &= ~(1U << SPI_CR1_SSI_Pos);
}

void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi)
{
	if (EnOrDi == ENABLE)
		pSPIx->CR2 |=  (1U << SPI_CR2_SSOE_Pos);
	else
		pSPIx->CR2 &= ~(1U << SPI_CR2_SSOE_Pos);
}

/* ============================== Error handling ============================= */
void SPI_ClearOVRFlag(SPI_RegDef_t *pSPIx)
{
	/* Clear OVR by reading DR then SR when RXNE=0 */
	volatile uint8_t temp;
	temp = (uint8_t)pSPIx->DR;
	(void)temp;
	temp = (uint8_t)pSPIx->SR;
	(void)temp;
}

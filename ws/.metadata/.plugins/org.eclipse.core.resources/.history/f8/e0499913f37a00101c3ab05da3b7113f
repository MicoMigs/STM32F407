/*
 * stm32f407xx_spi_driver.c
 */
#include "stm32f407xx_spi_driver.h"

/*********************************************************
 * @fn          - SPI_PeriClockControl
 * @brief       - Enables or disables peripheral clock for the given SPI
 *
 * @param[in]   pSPIx    - Base address of the SPI peripheral (SPI1/2/3)
 * @param[in]   EnOrDi   - ENABLE or DISABLE macro
 *
 * @return      - none
 *
 * @note        - Enable the clock before accessing SPI registers
 *********************************************************/
void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnorDi){
	if (EnorDi == ENABLE)
	{
		if (pSPIx == SPI1)
		{
			SPI1_PCLK_EN();
		}
		else if (pSPIx == SPI2)
		{
			SPI2_PCLK_EN();
		}
		else if (pSPIx == SPI3)
		{
			SPI3_PCLK_EN();
		}
	} else {
		if (pSPIx == SPI1)
		{
			SPI1_PCLK_DI();
		}
		else if (pSPIx == SPI2)
		{
			SPI2_PCLK_DI();
		}
		else if (pSPIx == SPI3)
		{
			SPI3_PCLK_DI();
		}
	}
}

/*********************************************************
 * @fn          - SPI_Init
 * @brief       - Initializes the SPI peripheral using fields in SPI_Handle_t
 *
 * @param[in]   pSPIHandle - Pointer to SPI handle with base and config
 *
 * @return      - none
 *
 * @note        - Configures CR1/CR2 (mode, BR, CPOL/CPHA, DFF, SSM/SSI, etc.)
 *              - Configure GPIO pins (AF, mode, speed, pull) separately
 *********************************************************/
void SPI_Init(SPI_Handle_t *pSPIHandle)
{
	//first lets configure the SPI_CR1 register
	uint32_t tempreg = 0;

	//1. CONFIGURE device mode
	tempreg |= pSPIHandle->SPIConfig.SPI_DeviceMode << SPI_CR1_MSTR;

	//2. CONFIGURE bus config
	if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD){
		//CLEAR BIDI mode
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
	}else if (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD){
		//SET BIDI mode
		tempreg |= (1 << SPI_CR1_BIDIMODE);
	}else if (pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SIMPLEX_RXONLY){
		//CLEAR BIDI mode
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
		//SET RXONLY bit
		tempreg &= ~(1 << SPI_CR1_BIDIMODE);
		tempreg |= (1 << SPI_CR1_RXONLY);
	}

	//3. Configure the SPI serial clock speed (baud rate)
	tempreg |= pSPIHandle->SPIConfig.SPI_SclkSpeed << SPI_CR1_BR;

	//4. Configure the DFF
	tempreg |= pSPIHandle->SPIConfig.SPI_DFF << SPI_CR1_DFF;

	//5. Configure the CPOL
	tempreg |= pSPIHandle->SPIConfig.SPI_CPOL << SPI_CR1_CPOL;

	//6. Configure the CPHA
	tempreg |= pSPIHandle->SPIConfig.SPI_CPHA << SPI_CR1_CPHA;

	pSPIHandle->pSPIx->CR1 = tempreg;

}

/*********************************************************
 * @fn          - SPI_DeInit
 * @brief       - Resets the SPI peripheral registers to default states
 *
 * @param[in]   pSPIx - Base address of the SPI peripheral
 *
 * @return      - none
 *
 * @note        - Uses APB reset bits in RCC to reset the block
 *********************************************************/
void SPI_DeInit(SPI_RegDef_t *pSPIx)
{
	if (pSPIx == SPI1)
	{
		SPI1_REG_RESET();
	}
	else if (pSPIx == SPI2)
	{
		SPI2_REG_RESET();
	}
	else if (pSPIx == SPI3)
	{
		SPI3_REG_RESET();
	}
	else
	{
		/* Invalid base address or unsupported instance */
	}
}

uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName)
{
	if(pSPIx->SR & FlagName)
	{
		return FLAG_SET;
	}
	return FLAG_RESET;
}

/*********************************************************
 * @fn          - SPI_SendData
 * @brief       - Sends data on SPI in blocking (polling) mode
 *
 * @param[in]   pSPIx      - Base address of the SPI peripheral
 * @param[in]   pTxBuffer  - Pointer to transmit buffer
 * @param[in]   Len        - Number of data bytes to send (8-bit DFF);
 *                           use even length when DFF=16-bit
 *
 * @return      - none
 *
 * @note        - Waits for TXE and BSY flags; blocks until complete
 *              - For full-duplex, RX path is ignored (may generate OVR)
 *********************************************************/
SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t *pTxBuffer, uint32_t Len)
{
	while(Len > 0){
		//1. WAIT until TXE is set
		while(SPI_GetFlagStatus(pSPIx, SPI_TXE_FLAG) == FLAG_RESET);

		//2. CHECK DFF bit in CR1
		if(pSPIx->CR1 & (1 << SPI_CR1_DFF))
		{
			//16 BIT DFF
			//1. LOAD data in DR
			pSPIx->DR = *((uint16_t*)pTxBuffer);
		}else{
			//8 bit DFF
		}
	}
}

/*********************************************************
 * @fn          - SPI_ReceiveData
 * @brief       - Receives data on SPI in blocking (polling) mode
 *
 * @param[in]   pSPIx      - Base address of the SPI peripheral
 * @param[out]  pRxBuffer  - Pointer to receive buffer
 * @param[in]   Len        - Number of data bytes to read (8-bit DFF);
 *                           use even length when DFF=16-bit
 *
 * @return      - none
 *
 * @note        - Waits for RXNE; blocks until Len bytes received
 *              - In master full-duplex, clock is generated by reading DR
 *********************************************************/
//void SPI_ReceiveData(SPI_RegDef_t *pSPIx, uint8_t *pRxBuffer, uint32_t Len);

/*********************************************************
 * @fn          - SPI_PeripheralControl
 * @brief       - Enables or disables the SPI peripheral (SPE bit)
 *
 * @param[in]   pSPIx    - Base address of the SPI peripheral
 * @param[in]   EnOrDi   - ENABLE or DISABLE macro
 *
 * @return      - none
 *
 * @note        - Only enable after CR1/CR2 and GPIO are configured
 *********************************************************/
//void SPI_PeripheralControl(SPI_RegDef_t *pSPIx, uint8_t EnOrDi);

/*********************************************************
 * @fn          - SPI_SSIConfig
 * @brief       - Controls the SSI bit (internal NSS) when SSM=1
 *
 * @param[in]   pSPIx    - Base address of the SPI peripheral
 * @param[in]   EnOrDi   - ENABLE(set) or DISABLE(clear) SSI
 *
 * @return      - none
 *
 * @note        - In master mode with SSM=1, set SSI to avoid MODF
 *********************************************************/
//void SPI_SSIConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi);

/*********************************************************
 * @fn          - SPI_SSOEConfig
 * @brief       - Enables or disables SS output (NSS) in master mode
 *
 * @param[in]   pSPIx    - Base address of the SPI peripheral
 * @param[in]   EnOrDi   - ENABLE or DISABLE macro
 *
 * @return      - none
 *
 * @note        - With SSOE=1 and hardware NSS, NSS is driven by SPE/BSY
 *********************************************************/
//void SPI_SSOEConfig(SPI_RegDef_t *pSPIx, uint8_t EnOrDi);

/*********************************************************
 * @fn          - SPI_GetFlagStatus
 * @brief       - Reads a status flag from the SPI SR register
 *
 * @param[in]   pSPIx     - Base address of the SPI peripheral
 * @param[in]   FlagName  - One of SPI_TXE_FLAG, SPI_RXNE_FLAG, SPI_BUSY_FLAG
 *
 * @return      - 1 if flag is set, 0 if flag is reset
 *
 * @note        - Returns a boolean-style value (uint8_t)
 *********************************************************/
//uint8_t SPI_GetFlagStatus(SPI_RegDef_t *pSPIx, uint32_t FlagName);

/*********************************************************
 * @fn          - SPI_ClearOVRFlag
 * @brief       - Clears the overrun (OVR) flag condition
 *
 * @param[in]   pSPIx - Base address of the SPI peripheral
 *
 * @return      - none
 *
 * @note        - Clear sequence: read DR, then read SR while RXNE=0
 *              - Do this after disabling SPI or after draining RX path
 *********************************************************/
//void SPI_ClearOVRFlag(SPI_RegDef_t *pSPIx);
